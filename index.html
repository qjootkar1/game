<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON HUNT: CYBERPUNK FPS</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #gameCanvas { display: block; width: 100vw; height: 100vh; }
        #startScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #00ffff; text-align: center; z-index: 10;
        }
        #startScreen h1 {
            font-size: 4em; margin-bottom: 1em;
            text-shadow: 0 0 20px #ff00ff, 0 0 40px #00ffff; letter-spacing: 5px;
        }
        #startBtn {
            padding: 15px 40px; font-size: 1.5em; background: transparent;
            color: #ff00ff; border: 2px solid #00ffff; cursor: pointer;
            text-transform: uppercase; letter-spacing: 3px; transition: all 0.3s;
        }
        #startBtn:hover {
            background: rgba(0, 255, 255, 0.1); box-shadow: 0 0 30px #00ffff;
        }
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; padding: 20px;
            color: white; z-index: 5; pointer-events: none;
        }
        #healthBarContainer {
            width: 300px; height: 20px; background: rgba(0,0,0,0.5);
            border: 2px solid #ff00ff; border-radius: 10px; overflow: hidden;
        }
        #healthBar {
            height: 100%; width: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            box-shadow: 0 0 10px #00ffff; transition: width 0.2s;
        }
        #stats, #enemyCount {
            margin-top: 10px; font-size: 1.2em; text-shadow: 0 0 10px #00ffff;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px; pointer-events: none; z-index: 5;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: #00ffff;
            box-shadow: 0 0 10px #00ffff, 0 0 20px #ff00ff;
        }
        #crosshair::before {
            top: 50%; left: 0; width: 16px; height: 2px; transform: translateY(-50%);
        }
        #crosshair::after {
            top: 0; left: 50%; width: 2px; height: 16px; transform: translateX(-50%);
        }
        #minimap {
            position: absolute; bottom: 20px; right: 20px;
            width: 150px; height: 150px; background: rgba(0,0,0,0.7);
            border: 2px solid #ff00ff; border-radius: 5px; z-index: 5;
        }
        #minimapCanvas { width: 100%; height: 100%; }
        #victoryScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85); color: #00ff00; z-index: 10;
        }
        #victoryScreen h1 {
            font-size: 5em; margin-bottom: 1em;
            text-shadow: 0 0 20px #00ff00; letter-spacing: 5px;
        }
        #restartBtn {
            padding: 15px 40px; font-size: 1.5em; background: transparent;
            color: #00ff00; border: 2px solid #00ff00; cursor: pointer;
            text-transform: uppercase; letter-spacing: 3px; transition: all 0.3s;
        }
        #restartBtn:hover {
            background: rgba(0, 255, 0, 0.1); box-shadow: 0 0 30px #00ff00;
        }
        #mobileControls {
            position: absolute; bottom: 20px; display: none; width: 100%; z-index: 10;
        }
        #joystickContainer, #fireBtnContainer {
            position: absolute; bottom: 20px; width: 100px; height: 100px;
            border-radius: 50%; background: rgba(0,255,255,0.2); border: 2px solid #00ffff;
        }
        #joystickContainer { left: 20px; }
        #fireBtnContainer { right: 20px; }
        #fireBtn {
            width: 100%; height: 100%; border: none;
            background: rgba(255,0,255,0.3); border-radius: 50%; cursor: pointer;
        }
        @media (max-width: 768px) {
            #mobileControls { display: block; }
            #startScreen h1 { font-size: 2.5em; }
            #startBtn { padding: 10px 20px; font-size: 1.2em; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="startScreen">
        <h1>NEON HUNT</h1>
        <button id="startBtn">ENTER NIGHT CITY</button>
    </div>
    <div id="hud">
        <div id="healthBarContainer"><div id="healthBar"></div></div>
        <div id="stats">FPS: <span id="fpsCounter">0</span></div>
        <div id="enemyCount">ENEMIES LEFT: <span id="enemyCounter">10</span></div>
    </div>
    <div id="crosshair"></div>
    <div id="minimap"><canvas id="minimapCanvas"></canvas></div>
    <div id="victoryScreen">
        <h1>HACK COMPLETE</h1>
        <button id="restartBtn">RESTART MISSION</button>
    </div>
    <div id="mobileControls">
        <div id="joystickContainer"></div>
        <div id="fireBtnContainer">
            <button id="fireBtn"></button>
        </div>
    </div>

    <!-- Three.js 핵심 라이브러리만 CDN으로 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.min.js"></script>

    <script>
        // ============= PointerLockControls 수동 구현 (전역 THREE에 등록) =============
        (function () {
            if (!window.THREE) return;
            const THREE = window.THREE;

            class PointerLockControls {
                constructor(camera, domElement) {
                    this.camera = camera;
                    this.domElement = domElement !== undefined ? domElement : document.body;
                    this.isLocked = false;
                    this._onMouseMove = this._onMouseMove.bind(this);
                    this._onPointerlockChange = this._onPointerlockChange.bind(this);
                    this._onPointerlockError = this._onPointerlockError.bind(this);
                    this.domElement.addEventListener('click', () => {
                        this.lock();
                    });
                    document.addEventListener('pointerlockchange', this._onPointerlockChange, false);
                    document.addEventListener('pointerlockerror', this._onPointerlockError, false);
                }

                lock() {
                    this.domElement.requestPointerLock();
                }

                unlock() {
                    document.exitPointerLock();
                }

                _onPointerlockChange() {
                    if (document.pointerLockElement === this.domElement) {
                        this.isLocked = true;
                        this.dispatchEvent({ type: 'lock' });
                    } else {
                        this.isLocked = false;
                        this.dispatchEvent({ type: 'unlock' });
                    }
                }

                _onPointerlockError() {
                    console.warn('PointerLockControls: Unable to use Pointer Lock API.');
                }

                _onMouseMove(event) {
                    if (!this.isLocked) return;
                    const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                    const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                    this.camera.rotation.y -= movementX * 0.002;
                    this.camera.rotation.x -= movementY * 0.002;
                    this.camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.camera.rotation.x));
                }

                connect() {
                    document.addEventListener('mousemove', this._onMouseMove, false);
                }

                disconnect() {
                    document.removeEventListener('mousemove', this._onMouseMove, false);
                }

                dispose() {
                    this.unlock();
                    document.removeEventListener('pointerlockchange', this._onPointerlockChange);
                    document.removeEventListener('pointerlockerror', this._onPointerlockError);
                    this.disconnect();
                }

                dispatchEvent(event) {
                    // 간단한 이벤트 시스템
                    if (this.callbacks && this.callbacks[event.type]) {
                        this.callbacks[event.type].forEach(cb => cb(event));
                    }
                }

                addEventListener(type, callback) {
                    if (!this.callbacks) this.callbacks = {};
                    if (!this.callbacks[type]) this.callbacks[type] = [];
                    this.callbacks[type].push(callback);
                }

                removeEventListener(type, callback) {
                    if (this.callbacks && this.callbacks[type]) {
                        const index = this.callbacks[type].indexOf(callback);
                        if (index !== -1) this.callbacks[type].splice(index, 1);
                    }
                }
            }

            // 전역 THREE에 등록
            THREE.PointerLockControls = PointerLockControls;
        })();
        // ===========================================================================

        // 나머지 게임 코드 (Three.js 전역 변수 사용)
        let scene, camera, renderer;
        let controls;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = true;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let playerHeight = 1.8;
        let playerHealth = 100;
        let isGameOver = false;
        let isZooming = false;
        let lastShotTime = 0;
        let shootCooldown = 150;
        let enemies = [];
        let clock = new THREE.Clock();
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let currentFps = 0;

        let backgroundMusic, shootSound, hitSound, enemyDieSound;
        let audioInitialized = false;

        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const victoryScreen = document.getElementById('victoryScreen');
        const restartBtn = document.getElementById('restartBtn');
        const healthBar = document.getElementById('healthBar');
        const enemyCounter = document.getElementById('enemyCounter');
        const fpsCounter = document.getElementById('fpsCounter');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const fireBtn = document.getElementById('fireBtn');
        const joystickContainer = document.getElementById('joystickContainer');

        function initAudio() {
            if (audioInitialized) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;

            const audioCtx = new AudioContext();
            const buffer = audioCtx.createBuffer(1, 1, 22050);
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(audioCtx.destination);
            source.start(0);

            backgroundMusic = new Audio();
            backgroundMusic.src = 'https://cdn.pixabay.com/download/audio/2022/03/15/audio_3a7e4d6c1c.mp3?filename=cinematic-ambient-cyberpunk-122197.mp3';
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.4;

            shootSound = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=");
            hitSound = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=");
            enemyDieSound = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=");

            shootSound.volume = 0.3;
            hitSound.volume = 0.5;
            enemyDieSound.volume = 0.4;

            audioInitialized = true;
        }

        function init() {
            const canvas = document.getElementById('gameCanvas');
            const width = window.innerWidth;
            const height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x00000f);
            scene.fog = new THREE.FogExp2(0x000011, 0.01);

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.y = playerHeight;

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xff00ff, 0.8);
            mainLight.position.set(50, 100, 50);
            mainLight.castShadow = true;
            scene.add(mainLight);

            const neonLights = [
                { color: 0x00ffff, pos: new THREE.Vector3(-20, 10, -10) },
                { color: 0xff00ff, pos: new THREE.Vector3(20, 8, -15) },
                { color: 0x00ff88, pos: new THREE.Vector3(0, 12, 20) }
            ];
            neonLights.forEach(lightInfo => {
                const pointLight = new THREE.PointLight(lightInfo.color, 2, 50);
                pointLight.position.copy(lightInfo.pos);
                pointLight.castShadow = true;
                scene.add(pointLight);

                const neonGeometry = new THREE.TorusGeometry(1.5, 0.1, 16, 100);
                const neonMaterial = new THREE.MeshBasicMaterial({ 
                    color: lightInfo.color,
                    emissive: lightInfo.color,
                    emissiveIntensity: 2
                });
                const neonMesh = new THREE.Mesh(neonGeometry, neonMaterial);
                neonMesh.position.copy(lightInfo.pos);
                scene.add(neonMesh);
            });

            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.1,
                metalness: 0.05,
                emissive: 0x000022,
                emissiveIntensity: 0.2
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            createEnvironment();
            createRain();
            createEnemies();

            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            // PointerLock 이벤트 연결
            controls.addEventListener('lock', () => {
                controls.connect();
            });
            controls.addEventListener('unlock', () => {
                controls.disconnect();
            });

            setupEventListeners();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createEnvironment() {
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x000044,
                emissiveIntensity: 0.3
            });
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 2,
                transparent: true,
                opacity: 0.8
            });

            const building1 = new THREE.Mesh(new THREE.BoxGeometry(10, 30, 5), buildingMaterial);
            building1.position.set(-15, 15, -20);
            building1.castShadow = true;
            building1.receiveShadow = true;
            scene.add(building1);

            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 3; j++) {
                    const win = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 0.1), windowMaterial);
                    win.position.set(-15 + (j - 1) * 2, 25 - i * 4, -20 - 2.5);
                    scene.add(win);
                }
            }

            const building2 = new THREE.Mesh(new THREE.BoxGeometry(8, 25, 6), buildingMaterial);
            building2.position.set(20, 12.5, -10);
            building2.castShadow = true;
            scene.add(building2);

            const neonSignGeometry = new THREE.BoxGeometry(4, 2, 0.1);
            const neonSignMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 5
            });
            const neonSign = new THREE.Mesh(neonSignGeometry, neonSignMaterial);
            neonSign.position.set(20, 20, -13);
            scene.add(neonSign);

            const fenceMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.8,
                metalness: 0.9
            });
            for (let i = 0; i < 20; i++) {
                const fence = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, 1), fenceMaterial);
                fence.position.set(-30 + i * 2, 1, 15);
                fence.castShadow = true;
                scene.add(fence);
            }

            const trashMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.7,
                metalness: 0.8
            });
            for (let i = 0; i < 5; i++) {
                const trash = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 1, 16), trashMaterial);
                trash.position.set(-25 + i * 3, 0.5, -5);
                trash.castShadow = true;
                scene.add(trash);
            }

            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 3
            });
            for (let i = 0; i < 8; i++) {
                const tube = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3, 8), tubeMaterial);
                tube.position.set(-10 + i * 3, 2, -25);
                tube.rotation.z = Math.PI / 2;
                scene.add(tube);
            }

            const hologramMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 4,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const hologram = new THREE.Mesh(new THREE.PlaneGeometry(6, 4), hologramMaterial);
            hologram.position.set(0, 5, 20);
            hologram.rotation.y = Math.PI / 2;
            scene.add(hologram);
        }

        function createRain() {
            const rainCount = 5000;
            const rainGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(rainCount * 3);
            const velocities = new Float32Array(rainCount * 3);

            for (let i = 0; i < rainCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 1] = Math.random() * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                velocities[i * 3] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 1] = -20 - Math.random() * 10;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
            }

            rainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            rainGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            const rainMaterial = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.2,
                transparent: true,
                opacity: 0.7
            });
            const rainParticles = new THREE.Points(rainGeometry, rainMaterial);
            scene.add(rainParticles);
        }

        function createEnemies() {
            const enemyGeometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
            const enemyMaterial = new THREE.MeshStandardMaterial({
                color: 0x220033,
                roughness: 0.8,
                metalness: 0.3
            });

            for (let i = 0; i < 10; i++) {
                const enemy = {};
                enemy.mesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                enemy.mesh.castShadow = true;
                enemy.mesh.position.set(
                    (Math.random() - 0.5) * 40,
                    1.25,
                    (Math.random() - 0.5) * 40 - 10
                );
                scene.add(enemy.mesh);

                const eyeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 5
                });
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                enemy.leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                enemy.leftEye.position.set(-0.3, 1.8, 0.3);
                enemy.mesh.add(enemy.leftEye);

                enemy.rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                enemy.rightEye.position.set(0.3, 1.8, 0.3);
                enemy.mesh.add(enemy.rightEye);

                enemy.alive = true;
                enemy.health = 30;
                enemy.lastAttack = 0;
                enemy.attackCooldown = 2000;
                enemy.speed = 0.8 + Math.random() * 0.4;
                enemies.push(enemy);
            }
            enemyCounter.textContent = enemies.length;
        }

        function setupEventListeners() {
            startBtn.addEventListener('click', () => {
                initAudio();
                if (backgroundMusic) {
                    backgroundMusic.play().catch(e => console.warn("Music play failed:", e));
                }
                startScreen.style.display = 'none';
                controls.lock();
            });

            restartBtn.addEventListener('click', resetGame);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);

            if (isMobile) {
                setupMobileControls();
            }
        }

        function setupMobileControls() {
            let isDragging = false;
            let baseX = 0, baseY = 0;
            const maxDistance = 50;

            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                baseX = touch.clientX;
                baseY = touch.clientY;
                isDragging = true;
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - baseX;
                const dy = touch.clientY - baseY;
                const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxDistance);
                const angle = Math.atan2(dy, dx);
                window.mobileJoystick = {
                    x: Math.cos(angle) * (distance / maxDistance),
                    y: Math.sin(angle) * (distance / maxDistance)
                };
            });

            document.addEventListener('touchend', () => {
                isDragging = false;
                window.mobileJoystick = { x: 0, y: 0 };
            });

            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                onMouseDown({ button: 0 });
            });

            fireBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                onMouseUp({ button: 0 });
            });
        }

        function onKeyDown(event) {
            if (isGameOver) return;
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = true; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
                case 'KeyS': case 'ArrowDown': moveBackward = true; break;
                case 'KeyD': case 'ArrowRight': moveRight = true; break;
                case 'Space': if (canJump) { velocity.y += 10; canJump = false; } break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = false; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
                case 'KeyS': case 'ArrowDown': moveBackward = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
            }
        }

        function onMouseDown(event) {
            if (isGameOver) return;
            const now = Date.now();
            if (event.button === 0) {
                if (now - lastShotTime > shootCooldown) {
                    shoot();
                    lastShotTime = now;
                }
            } else if (event.button === 2) {
                isZooming = true;
                camera.fov = 30;
                camera.updateProjectionMatrix();
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                isZooming = false;
                camera.fov = 75;
                camera.updateProjectionMatrix();
            }
        }

        function shoot() {
            if (!audioInitialized) return;
            if (shootSound) {
                shootSound.play().catch(e => console.warn("Shoot sound failed:", e));
            }

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const intersects = raycaster.intersectObjects(enemies.map(e => e.mesh));

            if (intersects.length > 0) {
                const hitEnemy = enemies.find(e => e.mesh === intersects[0].object);
                if (hitEnemy && hitEnemy.alive) {
                    hitEnemy.health -= 20;
                    if (hitSound) {
                        hitSound.play().catch(e => console.warn("Hit sound failed:", e));
                    }
                    createHitEffect(intersects[0].point);

                    if (hitEnemy.health <= 0) {
                        killEnemy(hitEnemy);
                    }
                }
            }

            applyRecoil();
        }

        function createHitEffect(position) {
            const particleCount = 20;
            const particles = new THREE.BufferGeometry();
            const pos = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                pos.set([position.x, position.y, position.z], i * 3);
                colors.set([1, 0, 1], i * 3);
                velocities.set([
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4
                ], i * 3);
            }

            particles.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            const system = new THREE.Points(particles, material);
            scene.add(system);

            const startTime = Date.now();
            const animateEffect = () => {
                const elapsed = Date.now() - startTime;
                if (elapsed < 500) {
                    const positions = system.geometry.attributes.position.array;
                    const vels = system.geometry.attributes.velocity.array;
                    for (let i = 0; i < particleCount * 3; i += 3) {
                        positions[i] += vels[i] * 0.016;
                        positions[i+1] += vels[i+1] * 0.016;
                        positions[i+2] += vels[i+2] * 0.016;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    requestAnimationFrame(animateEffect);
                } else {
                    scene.remove(system);
                    system.geometry.dispose();
                    system.material.dispose();
                }
            };
            animateEffect();
        }

        function applyRecoil() {
            const originalRotation = camera.rotation.x;
            camera.rotation.x -= 0.05;
            setTimeout(() => {
                camera.rotation.x = originalRotation;
            }, 100);
        }

        function killEnemy(enemy) {
            enemy.alive = false;
            enemy.mesh.visible = false;
            if (enemyDieSound) {
                enemyDieSound.play().catch(e => console.warn("Die sound failed:", e));
            }
            createExplosionEffect(enemy.mesh.position);

            const aliveCount = enemies.filter(e => e.alive).length;
            enemyCounter.textContent = aliveCount;

            if (aliveCount === 0) {
                setTimeout(() => {
                    victoryScreen.style.display = 'flex';
                    isGameOver = true;
                    if (backgroundMusic) backgroundMusic.pause();
                }, 500);
            }
        }

        function createExplosionEffect(position) {
            const particleCount = 50;
            const particles = new THREE.BufferGeometry();
            const pos = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                pos.set([position.x, position.y, position.z], i * 3);
                const r = Math.random() > 0.5 ? 1 : 0;
                const g = Math.random() > 0.5 ? 1 : 0;
                const b = Math.random() > 0.5 ? 1 : 0;
                colors.set([r, g, b], i * 3);
                velocities.set([
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5 + 2,
                    (Math.random() - 0.5) * 5
                ], i * 3);
            }

            particles.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9
            });

            const system = new THREE.Points(particles, material);
            scene.add(system);

            const startTime = Date.now();
            const animateEffect = () => {
                const elapsed = Date.now() - startTime;
                if (elapsed < 800) {
                    const positions = system.geometry.attributes.position.array;
                    const vels = system.geometry.attributes.velocity.array;
                    for (let i = 0; i < particleCount * 3; i += 3) {
                        positions[i] += vels[i] * 0.016;
                        positions[i+1] += vels[i+1] * 0.016;
                        positions[i+2] += vels[i+2] * 0.016;
                        vels[i+1] -= 0.3 * 0.016;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    requestAnimationFrame(animateEffect);
                } else {
                    scene.remove(system);
                    system.geometry.dispose();
                    system.material.dispose();
                }
            };
            animateEffect();
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
        }

        function resetGame() {
            playerHealth = 100;
            isGameOver = false;
            healthBar.style.width = '100%';
            victoryScreen.style.display = 'none';
            victoryScreen.querySelector('h1').textContent = 'HACK COMPLETE';
            victoryScreen.querySelector('h1').style.color = '#00ff00';
            victoryScreen.querySelector('h1').style.textShadow = '0 0 20px #00ff00';
            restartBtn.style.color = '#00ff00';
            restartBtn.style.borderColor = '#00ff00';

            if (backgroundMusic) {
                backgroundMusic.currentTime = 0;
                backgroundMusic.play().catch(e => console.warn("Restart music failed:", e));
            }

            enemies.forEach(enemy => {
                if (enemy.mesh.parent) scene.remove(enemy.mesh);
            });
            enemies = [];
            createEnemies();

            camera.position.set(0, playerHeight, 0);
            velocity.set(0, 0, 0);
        }

        function updateFps() {
            frameCount++;
            const now = performance.now();
            if (now >= lastFpsUpdate + 1000) {
                currentFps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                fpsCounter.textContent = currentFps;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        function updateMinimap() {
            minimapCtx.clearRect(0, 0, 150, 150);
            minimapCtx.fillStyle = '#000';
            minimapCtx.fillRect(0, 0, 150, 150);
            minimapCtx.fillStyle = '#00ff00';
            minimapCtx.fillRect(73, 73, 4, 4);

            enemies.forEach(enemy => {
                if (enemy.alive) {
                    const x = (enemy.mesh.position.x / 200) * 150 + 75;
                    const y = (enemy.mesh.position.z / 200) * 150 + 75;
                    if (x >= 0 && x <= 150 && y >= 0 && y <= 150) {
                        minimapCtx.fillStyle = '#ff0000';
                        minimapCtx.fillRect(x-2, y-2, 4, 4);
                    }
                }
            });

            minimapCtx.strokeStyle = '#ff00ff';
            minimapCtx.strokeRect(0, 0, 150, 150);
        }

        function updateRain(delta) {
            const rainSystem = scene.children.find(c => c.isPoints);
            if (!rainSystem) return;
            const positions = rainSystem.geometry.attributes.position.array;
            const velocities = rainSystem.geometry.attributes.velocity.array;
            const count = positions.length / 3;

            for (let i = 0; i < count; i++) {
                positions[i*3+1] += velocities[i*3+1] * delta;
                if (positions[i*3+1] < 0) {
                    positions[i*3+1] = 100;
                    positions[i*3] = (Math.random() - 0.5) * 200;
                    positions[i*3+2] = (Math.random() - 0.5) * 200;
                }
            }
            rainSystem.geometry.attributes.position.needsUpdate = true;
        }

        function updateEnemies(delta) {
            const playerPos = new THREE.Vector3();
            camera.getWorldPosition(playerPos);

            enemies.forEach(enemy => {
                if (!enemy.alive) return;
                const enemyPos = enemy.mesh.position;
                const direction = new THREE.Vector3();
                direction.subVectors(playerPos, enemyPos).normalize();
                enemy.mesh.position.x += direction.x * enemy.speed * delta;
                enemy.mesh.position.z += direction.z * enemy.speed * delta;
                enemy.mesh.lookAt(playerPos.x, enemyPos.y, playerPos.z);

                const distance = playerPos.distanceTo(enemyPos);
                if (distance < 3) {
                    const now = Date.now();
                    if (now - enemy.lastAttack > enemy.attackCooldown) {
                        playerHealth -= 10;
                        healthBar.style.width = Math.max(0, playerHealth) + '%';
                        enemy.lastAttack = now;
                        if (playerHealth <= 0) {
                            playerHealth = 0;
                            isGameOver = true;
                            if (backgroundMusic) backgroundMusic.pause();
                            setTimeout(() => {
                                victoryScreen.querySelector('h1').textContent = 'HACK FAILED';
                                victoryScreen.style.display = 'flex';
                                victoryScreen.querySelector('h1').style.color = '#ff0000';
                                victoryScreen.querySelector('h1').style.textShadow = '0 0 20px #ff0000';
                                restartBtn.style.color = '#ff0000';
                                restartBtn.style.borderColor = '#ff0000';
                            }, 1000);
                        }
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isGameOver) return;

            const delta = Math.min(clock.getDelta(), 0.1);
            updateFps();
            updateMinimap();
            updateRain(delta);
            updateEnemies(delta);

            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                if (isMobile && window.mobileJoystick) {
                    direction.x += window.mobileJoystick.x;
                    direction.z -= window.mobileJoystick.y;
                }
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 40.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 40.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                camera.position.y += velocity.y * delta;
                if (camera.position.y < playerHeight) {
                    velocity.y = 0;
                    camera.position.y = playerHeight;
                    canJump = true;
                }
            }

            renderer.render(scene, camera);
        }

        // 게임은 버튼 클릭 시 시작됨
    </script>
</body>
</html>
