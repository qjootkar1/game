```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON HUNT: CYBERPUNK FPS</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            font-family: 'Courier New', monospace;
        }
        #gameCanvas { 
            display: block; 
            width: 100vw; 
            height: 100vh;
        }
        #startScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #00ffff;
            text-align: center;
            z-index: 10;
        }
        #startScreen h1 {
            font-size: 4em;
            margin-bottom: 1em;
            text-shadow: 0 0 20px #ff00ff, 0 0 40px #00ffff;
            letter-spacing: 5px;
        }
        #startBtn {
            padding: 15px 40px;
            font-size: 1.5em;
            background: transparent;
            color: #ff00ff;
            border: 2px solid #00ffff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s;
        }
        #startBtn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 30px #00ffff;
        }
        #hud {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            padding: 20px;
            color: white;
            z-index: 5;
            pointer-events: none;
        }
        #healthBarContainer {
            width: 300px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            overflow: hidden;
        }
        #healthBar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            box-shadow: 0 0 10px #00ffff;
            transition: width 0.2s;
        }
        #stats, #enemyCount {
            margin-top: 10px;
            font-size: 1.2em;
            text-shadow: 0 0 10px #00ffff;
        }
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 40px; height: 40px;
            pointer-events: none;
            z-index: 5;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #00ffff;
            box-shadow: 0 0 10px #00ffff, 0 0 20px #ff00ff;
        }
        #crosshair::before {
            top: 50%; left: 0;
            width: 16px; height: 2px;
            transform: translateY(-50%);
        }
        #crosshair::after {
            top: 0; left: 50%;
            width: 2px; height: 16px;
            transform: translateX(-50%);
        }
        #minimap {
            position: absolute;
            bottom: 20px; right: 20px;
            width: 150px; height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ff00ff;
            border-radius: 5px;
            z-index: 5;
        }
        #minimapCanvas {
            width: 100%; height: 100%;
        }
        #victoryScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.85);
            color: #00ff00;
            z-index: 10;
        }
        #victoryScreen h1 {
            font-size: 5em;
            margin-bottom: 1em;
            text-shadow: 0 0 20px #00ff00;
            letter-spacing: 5px;
        }
        #restartBtn {
            padding: 15px 40px;
            font-size: 1.5em;
            background: transparent;
            color: #00ff00;
            border: 2px solid #00ff00;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s;
        }
        #restartBtn:hover {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 30px #00ff00;
        }
        #mobileControls {
            position: absolute;
            bottom: 20px;
            display: none;
            width: 100%;
            z-index: 10;
        }
        #joystickContainer, #fireBtnContainer {
            position: absolute;
            bottom: 20px;
            width: 100px; height: 100px;
            border-radius: 50%;
            background: rgba(0,255,255,0.2);
            border: 2px solid #00ffff;
        }
        #joystickContainer {
            left: 20px;
        }
        #fireBtnContainer {
            right: 20px;
        }
        #fireBtn {
            width: 100%; height: 100%;
            border: none;
            background: rgba(255,0,255,0.3);
            border-radius: 50%;
            cursor: pointer;
        }
        @media (max-width: 768px) {
            #mobileControls { display: block; }
            #startScreen h1 { font-size: 2.5em; }
            #startBtn { padding: 10px 20px; font-size: 1.2em; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen">
        <h1>NEON HUNT</h1>
        <button id="startBtn">ENTER NIGHT CITY</button>
    </div>

    <div id="hud">
        <div id="healthBarContainer"><div id="healthBar"></div></div>
        <div id="stats">FPS: <span id="fpsCounter">0</span></div>
        <div id="enemyCount">ENEMIES LEFT: <span id="enemyCounter">10</span></div>
    </div>

    <div id="crosshair"></div>
    <div id="minimap"><canvas id="minimapCanvas"></canvas></div>

    <div id="victoryScreen">
        <h1>HACK COMPLETE</h1>
        <button id="restartBtn">RESTART MISSION</button>
    </div>

    <div id="mobileControls">
        <div id="joystickContainer"></div>
        <div id="fireBtnContainer">
            <button id="fireBtn"></button>
        </div>
    </div>

    <!-- Three.js 및 관련 모듈 로드 -->
    <script type="module">
        // Three.js r181+ CDN에서 모듈 로드
        import * as THREE from 'https://cdn.skypack.dev/three@0.181.0';
        import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.181.0/examples/jsm/controls/PointerLockControls.js';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.181.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.181.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.181.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { GlitchPass } from 'https://cdn.skypack.dev/three@0.181.0/examples/jsm/postprocessing/GlitchPass.js';
        import { FilmPass } from 'https://cdn.skypack.dev/three@0.181.0/examples/jsm/postprocessing/FilmPass.js';

        // 게임 상태 변수
        let scene, camera, renderer, composer;
        let controls;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = true;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let playerHeight = 1.8;
        let playerHealth = 100;
        let isGameOver = false;
        let isZooming = false;
        let lastShotTime = 0;
        let shootCooldown = 150; // 밀리초
        let enemies = [];
        let bullets = [];
        let rainParticles;
        let groundMesh;
        let clock = new THREE.Clock();
        let lastRainUpdate = 0;
        let rainSpeed = 20;
        let mobileJoystick = { x: 0, y: 0 };
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let lastFpsUpdate = 0;
        let frameCount = 0;
        let currentFps = 0;

        // 오디오 컨텍스트 및 사운드
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let backgroundMusic, shootSound, hitSound, enemyDieSound;

        // DOM 요소 참조
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const victoryScreen = document.getElementById('victoryScreen');
        const restartBtn = document.getElementById('restartBtn');
        const healthBar = document.getElementById('healthBar');
        const enemyCounter = document.getElementById('enemyCounter');
        const fpsCounter = document.getElementById('fpsCounter');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const fireBtn = document.getElementById('fireBtn');
        const joystickContainer = document.getElementById('joystickContainer');

        // 게임 초기화
        function init() {
            // 캔버스 크기 설정
            const canvas = document.getElementById('gameCanvas');
            const width = window.innerWidth;
            const height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            // 씬 생성
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x00000f);
            scene.fog = new THREE.FogExp2(0x000011, 0.01);

            // 카메라 생성
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.y = playerHeight;

            // 렌더러 생성
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // 포스트 프로세싱 설정 (블룸, 글리치, 필름)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(width, height),
                1.5,    // 강도
                0.4,    // 반경
                0.85    // 임계값
            );
            const glitchPass = new GlitchPass();
            glitchPass.goWild = false; // 자동 글리치 비활성화
            const filmPass = new FilmPass(0.35, 0.025, 448, false); // 네온 필름 효과

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(filmPass);
            // GlitchPass는 성능을 위해 생략 (필요시 활성화 가능)

            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // 주요 조명 (네온 느낌 강조)
            const mainLight = new THREE.DirectionalLight(0xff00ff, 0.8);
            mainLight.position.set(50, 100, 50);
            mainLight.castShadow = true;
            scene.add(mainLight);

            // 추가 네온 조명
            const neonLights = [
                { color: 0x00ffff, pos: new THREE.Vector3(-20, 10, -10) },
                { color: 0xff00ff, pos: new THREE.Vector3(20, 8, -15) },
                { color: 0x00ff88, pos: new THREE.Vector3(0, 12, 20) }
            ];
            neonLights.forEach(lightInfo => {
                const pointLight = new THREE.PointLight(lightInfo.color, 2, 50);
                pointLight.position.copy(lightInfo.pos);
                pointLight.castShadow = true;
                scene.add(pointLight);

                // 네온 빛의 에미시브 효과를 위해 도넛 메시 추가
                const neonGeometry = new THREE.TorusGeometry(1.5, 0.1, 16, 100);
                const neonMaterial = new THREE.MeshBasicMaterial({ 
                    color: lightInfo.color,
                    emissive: lightInfo.color,
                    emissiveIntensity: 2
                });
                const neonMesh = new THREE.Mesh(neonGeometry, neonMaterial);
                neonMesh.position.copy(lightInfo.pos);
                scene.add(neonMesh);
            });

            // 지면 생성 (젖은 아스팔트 - PBR 재질)
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.1, // 매끄럽게
                metalness: 0.05,
                emissive: 0x000022,
                emissiveIntensity: 0.2
            });
            groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // 사이버펑크 오브젝트 생성 (빌딩, 네온 사인 등)
            createEnvironment();

            // 비 효과 (입자 시스템)
            createRain();

            // 적 생성
            createEnemies();

            // Pointer Lock 컨트롤 설정
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            // 이벤트 리스너 설정
            setupEventListeners();

            // 사운드 초기화
            initSounds();

            // 창 크기 변경 핸들러
            window.addEventListener('resize', onWindowResize);

            // 게임 루프 시작
            animate();
        }

        // 사이버펑크 환경 오브젝트 생성
        function createEnvironment() {
            // 빌딩 생성
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x000044,
                emissiveIntensity: 0.3
            });
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 2,
                transparent: true,
                opacity: 0.8
            });

            // 빌딩 1
            const building1 = new THREE.Mesh(
                new THREE.BoxGeometry(10, 30, 5),
                buildingMaterial
            );
            building1.position.set(-15, 15, -20);
            building1.castShadow = true;
            building1.receiveShadow = true;
            scene.add(building1);

            // 창문
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 3; j++) {
                    const win = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 1.5, 0.1),
                        windowMaterial
                    );
                    win.position.set(
                        -15 + (j - 1) * 2,
                        25 - i * 4,
                        -20 - 2.5
                    );
                    scene.add(win);
                }
            }

            // 빌딩 2
            const building2 = new THREE.Mesh(
                new THREE.BoxGeometry(8, 25, 6),
                buildingMaterial
            );
            building2.position.set(20, 12.5, -10);
            building2.castShadow = true;
            scene.add(building2);

            // 네온 사인
            const neonSignGeometry = new THREE.BoxGeometry(4, 2, 0.1);
            const neonSignMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 5
            });
            const neonSign = new THREE.Mesh(neonSignGeometry, neonSignMaterial);
            neonSign.position.set(20, 20, -13);
            scene.add(neonSign);

            // 체인링크 펜스
            const fenceMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.8,
                metalness: 0.9
            });
            for (let i = 0; i < 20; i++) {
                const fence = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 2, 1),
                    fenceMaterial
                );
                fence.position.set(-30 + i * 2, 1, 15);
                fence.castShadow = true;
                scene.add(fence);
            }

            // 쓰레기통
            const trashMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.7,
                metalness: 0.8
            });
            for (let i = 0; i < 5; i++) {
                const trash = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 1, 16),
                    trashMaterial
                );
                trash.position.set(-25 + i * 3, 0.5, -5);
                trash.castShadow = true;
                scene.add(trash);
            }

            // 포장마루 네온 튜브
            const tubeGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 3
            });
            for (let i = 0; i < 8; i++) {
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tube.position.set(-10 + i * 3, 2, -25);
                tube.rotation.z = Math.PI / 2;
                scene.add(tube);
            }

            // 홀로그램 광고판
            const hologramMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 4,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const hologram = new THREE.Mesh(
                new THREE.PlaneGeometry(6, 4),
                hologramMaterial
            );
            hologram.position.set(0, 5, 20);
            hologram.rotation.y = Math.PI / 2;
            scene.add(hologram);
        }

        // 비 효과 생성
        function createRain() {
            const rainCount = 15000;
            const rainGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(rainCount * 3);
            const velocities = new Float32Array(rainCount * 3);

            for (let i = 0; i < rainCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 1] = Math.random() * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;

                velocities[i * 3] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 1] = -rainSpeed - Math.random() * 10;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
            }

            rainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            rainGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

            const rainMaterial = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.2,
                transparent: true,
                opacity: 0.7,
                sizeAttenuation: true
            });

            rainParticles = new THREE.Points(rainGeometry, rainMaterial);
            scene.add(rainParticles);
        }

        // 적 생성 (사이버 좀비)
        function createEnemies() {
            const enemyGeometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
            const enemyMaterial = new THREE.MeshStandardMaterial({
                color: 0x220033,
                roughness: 0.8,
                metalness: 0.3
            });

            for (let i = 0; i < 10; i++) {
                const enemy = {};
                enemy.mesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                enemy.mesh.castShadow = true;
                enemy.mesh.position.set(
                    (Math.random() - 0.5) * 40,
                    1.25,
                    (Math.random() - 0.5) * 40 - 10
                );
                scene.add(enemy.mesh);

                // 빨간 네온 눈
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 5
                });
                enemy.leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                enemy.leftEye.position.set(-0.3, 1.8, 0.3);
                enemy.mesh.add(enemy.leftEye);

                enemy.rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                enemy.rightEye.position.set(0.3, 1.8, 0.3);
                enemy.mesh.add(enemy.rightEye);

                enemy.alive = true;
                enemy.health = 30;
                enemy.lastAttack = 0;
                enemy.attackCooldown = 2000; // 2초
                enemy.speed = 0.8 + Math.random() * 0.4;
                enemies.push(enemy);
            }
            enemyCounter.textContent = enemies.length;
        }

        // 사운드 초기화
        function initSounds() {
            // 배경음악 (사이버펑크 앰비언트)
            backgroundMusic = new Audio();
            backgroundMusic.src = 'https://cdn.pixabay.com/download/audio/2022/03/15/audio_3a7e4d6c1c.mp3?filename=cinematic-ambient-cyberpunk-122197.mp3';
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.4;

            // 총소리
            shootSound = new Audio();
            shootSound.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFfHl1cGtqamloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAA';
            shootSound.volume = 0.3;

            // 맞는 소리
            hitSound = new Audio();
            hitSound.src = 'data:audio/wav;base64,UklGRiQEAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAEAAD+/wAA/v//AP3+/gD9/v4A/f7+AP7+/gD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v//AP7//wD+//8A/v......';
            hitSound.volume = 0.5;

            // 적 죽는 소리
            enemyDieSound = new Audio();
            enemyDieSound.src = 'data:audio/wav;base64,UklGRl4GAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQIGAACJi46Ni4qJh4aFhIOCgYB/fn18e3p5eHd2dXR0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAA';
            enemyDieSound.volume = 0.4;
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            startBtn.addEventListener('click', () => {
                startScreen.style.display = 'none';
                controls.lock();
                backgroundMusic.play().catch(e => console.log("Audio play failed:", e));
            });

            restartBtn.addEventListener('click', resetGame);

            // 키보드 입력
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // 마우스 입력
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);

            // 모바일 조이스틱
            if (isMobile) {
                setupMobileControls();
            }
        }

        // 모바일 조이스틱 설정
        function setupMobileControls() {
            let isDragging = false;
            let baseX = 0, baseY = 0;

            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                baseX = touch.clientX;
                baseY = touch.clientY;
                isDragging = true;
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - baseX;
                const dy = touch.clientY - baseY;
                const maxDistance = 50;
                const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxDistance);
                const angle = Math.atan2(dy, dx);
                mobileJoystick.x = Math.cos(angle) * (distance / maxDistance);
                mobileJoystick.y = Math.sin(angle) * (distance / maxDistance);
            });

            document.addEventListener('touchend', () => {
                isDragging = false;
                mobileJoystick.x = 0;
                mobileJoystick.y = 0;
            });

            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                onMouseDown({ button: 0 });
            });

            fireBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                onMouseUp({ button: 0 });
            });
        }

        // 키보드 입력 핸들러
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = true; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
                case 'KeyS': case 'ArrowDown': moveBackward = true; break;
                case 'KeyD': case 'ArrowRight': moveRight = true; break;
                case 'Space': if (canJump) { velocity.y += 10; canJump = false; } break;
                case 'ShiftLeft': case 'ShiftRight': // 달리기 (단순히 속도 증가)
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = false; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
                case 'KeyS': case 'ArrowDown': moveBackward = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
            }
        }

        // 마우스 입력 핸들러
        function onMouseDown(event) {
            if (isGameOver) return;
            const now = Date.now();
            if (event.button === 0) { // 왼쪽 클릭 - 사격
                if (now - lastShotTime > shootCooldown) {
                    shoot();
                    lastShotTime = now;
                }
            } else if (event.button === 2) { // 오른쪽 클릭 - 줌
                isZooming = true;
                camera.fov = 30;
                camera.updateProjectionMatrix();
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                isZooming = false;
                camera.fov = 75;
                camera.updateProjectionMatrix();
            }
        }

        function onMouseMove(event) {
            // 마우스 이동은 PointerLockControls가 자동 처리
        }

        // 사격 함수
        function shoot() {
            if (isGameOver) return;
            shootSound.currentTime = 0;
            shootSound.play().catch(e => console.log("Shoot sound failed:", e));

            // 카메라 방향으로 레이캐스트
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const intersects = raycaster.intersectObjects(enemies.map(e => e.mesh));

            // 히트스캔
            if (intersects.length > 0) {
                const hitEnemy = enemies.find(e => e.mesh === intersects[0].object);
                if (hitEnemy && hitEnemy.alive) {
                    hitEnemy.health -= 20;
                    hitSound.currentTime = 0;
                    hitSound.play().catch(e => console.log("Hit sound failed:", e));
                    createHitEffect(intersects[0].point);
                    createLaserLine(camera.position, intersects[0].point);

                    if (hitEnemy.health <= 0) {
                        killEnemy(hitEnemy);
                    }
                }
            } else {
                // 레이저 라인 (공중에)
                const farPoint = raycaster.ray.at(100);
                createLaserLine(camera.position, farPoint);
            }

            // 리코일 (카메라 흔들림)
            applyRecoil();
        }

        // 레이저 라인 생성
        function createLaserLine(start, end) {
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);

            // 일정 시간 후 제거
            setTimeout(() => {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            }, 100);
        }

        // 맞은 이펙트 생성
        function createHitEffect(position) {
            const particleCount = 20;
            const particles = new THREE.BufferGeometry();
            const pos = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                pos.set([position.x, position.y, position.z], i * 3);
                colors.set([1, 0, 1], i * 3); // 보라색
                velocities.set([
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4
                ], i * 3);
            }

            particles.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            const system = new THREE.Points(particles, material);
            scene.add(system);

            // 이펙트 애니메이션 및 제거
            const startTime = Date.now();
            const duration = 500;
            const animateEffect = () => {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const positions = system.geometry.attributes.position.array;
                    const vels = system.geometry.attributes.velocity.array;
                    for (let i = 0; i < particleCount * 3; i += 3) {
                        positions[i] += vels[i] * 0.016;
                        positions[i+1] += vels[i+1] * 0.016;
                        positions[i+2] += vels[i+2] * 0.016;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    requestAnimationFrame(animateEffect);
                } else {
                    scene.remove(system);
                    system.geometry.dispose();
                    system.material.dispose();
                }
            };
            animateEffect();
        }

        // 리코일 적용
        function applyRecoil() {
            const originalRotation = camera.rotation.x;
            camera.rotation.x -= 0.05;
            setTimeout(() => {
                camera.rotation.x = originalRotation;
            }, 100);
        }

        // 적 제거
        function killEnemy(enemy) {
            enemy.alive = false;
            enemy.mesh.visible = false;
            enemyDieSound.currentTime = 0;
            enemyDieSound.play().catch(e => console.log("Die sound failed:", e));
            createExplosionEffect(enemy.mesh.position);

            // 남은 적 수 업데이트
            const aliveCount = enemies.filter(e => e.alive).length;
            enemyCounter.textContent = aliveCount;

            if (aliveCount === 0) {
                setTimeout(() => {
                    victoryScreen.style.display = 'flex';
                    isGameOver = true;
                    backgroundMusic.pause();
                }, 500);
            }
        }

        // 폭발 이펙트 생성
        function createExplosionEffect(position) {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const pos = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                pos.set([position.x, position.y, position.z], i * 3);
                // 무작위 색상 (보라, 청록)
                const r = Math.random() > 0.5 ? 1 : 0;
                const g = Math.random() > 0.5 ? 1 : 0;
                const b = Math.random() > 0.5 ? 1 : 0;
                colors.set([r, g, b], i * 3);
                velocities.set([
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10 + 2,
                    (Math.random() - 0.5) * 10
                ], i * 3);
                sizes[i] = Math.random() * 0.5 + 0.1;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 1,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });

            const system = new THREE.Points(particles, material);
            scene.add(system);

            // 이펙트 애니메이션 및 제거
            const startTime = Date.now();
            const duration = 1000;
            const animateEffect = () => {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const positions = system.geometry.attributes.position.array;
                    const vels = system.geometry.attributes.velocity.array;
                    const opacities = 1 - (elapsed / duration);
                    for (let i = 0; i < particleCount * 3; i += 3) {
                        positions[i] += vels[i] * 0.016;
                        positions[i+1] += vels[i+1] * 0.016;
                        positions[i+2] += vels[i+2] * 0.016;
                        vels[i+1] -= 0.5 * 0.016; // 중력
                    }
                    system.material.opacity = opacities;
                    system.geometry.attributes.position.needsUpdate = true;
                    requestAnimationFrame(animateEffect);
                } else {
                    scene.remove(system);
                    system.geometry.dispose();
                    system.material.dispose();
                }
            };
            animateEffect();
        }

        // 창 크기 변경 핸들러
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height);
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
        }

        // 게임 재시작
        function resetGame() {
            // 상태 초기화
            playerHealth = 100;
            isGameOver = false;
            healthBar.style.width = '100%';
            victoryScreen.style.display = 'none';
            backgroundMusic.currentTime = 0;
            backgroundMusic.play().catch(e => console.log("Audio play failed:", e));

            // 적 재생성
            enemies.forEach(enemy => {
                if (enemy.mesh.parent) scene.remove(enemy.mesh);
            });
            enemies = [];
            createEnemies();

            // 카메라 초기 위치
            camera.position.set(0, playerHeight, 0);
            velocity.set(0, 0, 0);
        }

        // FPS 계산
        function updateFps() {
            frameCount++;
            const now = performance.now();
            if (now >= lastFpsUpdate + 1000) {
                currentFps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                fpsCounter.textContent = currentFps;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // 미니맵 업데이트
        function updateMinimap() {
            minimapCtx.clearRect(0, 0, 150, 150);
            minimapCtx.fillStyle = '#000';
            minimapCtx.fillRect(0, 0, 150, 150);

            // 플레이어 위치 (중앙)
            minimapCtx.fillStyle = '#00ff00';
            minimapCtx.fillRect(73, 73, 4, 4);

            // 적 위치
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    const x = (enemy.mesh.position.x / 200) * 150 + 75;
                    const y = (enemy.mesh.position.z / 200) * 150 + 75;
                    if (x >= 0 && x <= 150 && y >= 0 && y <= 150) {
                        minimapCtx.fillStyle = '#ff0000';
                        minimapCtx.fillRect(x-2, y-2, 4, 4);
                    }
                }
            });

            // 경계
            minimapCtx.strokeStyle = '#ff00ff';
            minimapCtx.strokeRect(0, 0, 150, 150);
        }

        // 비 입자 업데이트
        function updateRain(delta) {
            if (!rainParticles) return;
            const positions = rainParticles.geometry.attributes.position.array;
            const velocities = rainParticles.geometry.attributes.velocity.array;
            const count = positions.length / 3;

            for (let i = 0; i < count; i++) {
                positions[i*3+1] += velocities[i*3+1] * delta;
                // 비가 땅에 닿으면 위로 리셋
                if (positions[i*3+1] < 0) {
                    positions[i*3+1] = 100;
                    positions[i*3] = (Math.random() - 0.5) * 200;
                    positions[i*3+2] = (Math.random() - 0.5) * 200;
                }
            }
            rainParticles.geometry.attributes.position.needsUpdate = true;
        }

        // 적 AI 업데이트
        function updateEnemies(delta) {
            const playerPos = new THREE.Vector3();
            camera.getWorldPosition(playerPos);

            enemies.forEach(enemy => {
                if (!enemy.alive) return;

                const enemyPos = enemy.mesh.position;
                const direction = new THREE.Vector3();
                direction.subVectors(playerPos, enemyPos).normalize();

                // 플레이어 추적
                enemy.mesh.position.x += direction.x * enemy.speed * delta;
                enemy.mesh.position.z += direction.z * enemy.speed * delta;

                // 플레이어 바라보기
                enemy.mesh.lookAt(playerPos.x, enemyPos.y, playerPos.z);

                // 공격 (근접)
                const distance = playerPos.distanceTo(enemyPos);
                if (distance < 3) {
                    const now = Date.now();
                    if (now - enemy.lastAttack > enemy.attackCooldown) {
                        playerHealth -= 10;
                        healthBar.style.width = playerHealth + '%';
                        enemy.lastAttack = now;
                        if (playerHealth <= 0) {
                            playerHealth = 0;
                            healthBar.style.width = '0%';
                            isGameOver = true;
                            backgroundMusic.pause();
                            setTimeout(() => {
                                victoryScreen.querySelector('h1').textContent = 'HACK FAILED';
                                victoryScreen.style.display = 'flex';
                                victoryScreen.querySelector('h1').style.color = '#ff0000';
                                victoryScreen.querySelector('h1').style.textShadow = '0 0 20px #ff0000';
                                restartBtn.style.color = '#ff0000';
                                restartBtn.style.borderColor = '#ff0000';
                            }, 1000);
                        }
                    }
                }
            });
        }

        // 게임 루프
        function animate() {
            requestAnimationFrame(animate);

            if (isGameOver) return;

            const delta = Math.min(clock.getDelta(), 0.1); // 최대 델타 제한

            // FPS 및 미니맵 업데이트
            updateFps();
            updateMinimap();

            // 비 업데이트
            updateRain(delta);

            // 적 AI 업데이트
            updateEnemies(delta);

            // 플레이어 이동
            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 10.0 * delta; // 중력

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                // 모바일 조이스틱 입력 처리
                if (isMobile) {
                    direction.x += mobileJoystick.x;
                    direction.z -= mobileJoystick.y;
                }

                if (moveForward || moveBackward) velocity.z -= direction.z * 40.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 40.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                camera.position.y += velocity.y * delta;
                if (camera.position.y < playerHeight) {
                    velocity.y = 0;
                    camera.position.y = playerHeight;
                    canJump = true;
                }
            }

            // 렌더링
            composer.render();
        }

        // 초기화 시작
        init();
    </script>
</body>
</html>
```
